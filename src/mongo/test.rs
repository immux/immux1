#[cfg(test)]
mod tests {
    use crate::mongo::header_parser::parse_msg_header;
    use crate::mongo::op_reply_parser::parse_op_reply;
    use crate::mongo::utils::{parse_u64};

    fn get_bufer() -> &'static [u8] {
        let buffer: &[u8] = &[
            0xef,0x00,0x00,0x00,0x91,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,
            0x08,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
            0x01,0x00,0x00,0x00,0xcb,0x00,0x00,0x00,0x08,0x69,0x73,0x6d,0x61,0x73,0x74,0x65,
            0x72,0x00,0x01,0x10,0x6d,0x61,0x78,0x42,0x73,0x6f,0x6e,0x4f,0x62,0x6a,0x65,0x63,
            0x74,0x53,0x69,0x7a,0x65,0x00,0x00,0x00,0x00,0x01,0x10,0x6d,0x61,0x78,0x4d,0x65,
            0x73,0x73,0x61,0x67,0x65,0x53,0x69,0x7a,0x65,0x42,0x79,0x74,0x65,0x73,0x00,0x00,
            0x6c,0xdc,0x02,0x10,0x6d,0x61,0x78,0x57,0x72,0x69,0x74,0x65,0x42,0x61,0x74,0x63,
            0x68,0x53,0x69,0x7a,0x65,0x00,0xa0,0x86,0x01,0x00,0x09,0x6c,0x6f,0x63,0x61,0x6c,
            0x54,0x69,0x6d,0x65,0x00,0x9e,0xd1,0xfe,0xbc,0x69,0x01,0x00,0x00,0x10,0x6c,0x6f,
            0x67,0x69,0x63,0x61,0x6c,0x53,0x65,0x73,0x73,0x69,0x6f,0x6e,0x54,0x69,0x6d,0x65,
            0x6f,0x75,0x74,0x4d,0x69,0x6e,0x75,0x74,0x65,0x73,0x00,0x1e,0x00,0x00,0x00,0x10,
            0x6d,0x69,0x6e,0x57,0x69,0x72,0x65,0x56,0x65,0x72,0x73,0x69,0x6f,0x6e,0x00,0x00,
            0x00,0x00,0x00,0x10,0x6d,0x61,0x78,0x57,0x69,0x72,0x65,0x56,0x65,0x72,0x73,0x69,
            0x6f,0x6e,0x00,0x07,0x00,0x00,0x00,0x08,0x72,0x65,0x61,0x64,0x4f,0x6e,0x6c,0x79,
            0x00,0x00,0x01,0x6f,0x6b,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xf0,0x3f,0x00
        ];
        buffer
    }

    #[test]
    fn test_parse_u64() {
        let res = parse_u64(&[0x0d, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]);
        let (num, next_buffer) = res.unwrap();
        assert_eq!(269, num);
        assert_eq!(next_buffer.len(), 0);
    }

    #[test]
    fn test_parse_u64_error() {
        match parse_u64(&[0x0d]) {
            Ok(_) => {
                assert!(false, "buffer size less then 8 should return an error");
            }
            Err(_) => {
                assert!(true);
            }
        }
    }

    #[test]
    fn test_parse_op_reply() {
        let buffer = get_bufer();
        let (header, next_buffer) = parse_msg_header(buffer).unwrap();
        let op_query = parse_op_reply(header, next_buffer).unwrap();
        assert_eq!(op_query.response_flags, 8);
        assert_eq!(op_query.cursor_id, 0);
        assert_eq!(op_query.starting_from, 0);
        assert_eq!(op_query.number_returned, 1);
        assert_eq!(op_query.documents.len(), (op_query.number_returned as usize));
        assert_eq!(op_query.documents[0].contains_key("ismaster"), true);
        assert_eq!(op_query.documents[0].contains_key("maxBsonObjectSize"), true);
        assert_eq!(op_query.documents[0].contains_key("maxMessageSizeBytes"), true);
        assert_eq!(op_query.documents[0].contains_key("maxWriteBatchSize"), true);
        assert_eq!(op_query.documents[0].contains_key("localTime"), true);
        assert_eq!(op_query.documents[0].contains_key("logicalSessionTimeoutMinutes"), true);
        assert_eq!(op_query.documents[0].contains_key("minWireVersion"), true);
        assert_eq!(op_query.documents[0].contains_key("maxWireVersion"), true);
        assert_eq!(op_query.documents[0].contains_key("readOnly"), true);
        assert_eq!(op_query.documents[0].contains_key("ok"), true);
    }
}

#[cfg(test)]
mod tests {
    use crate::mongo::header_parser::parse_msg_header;
    use crate::mongo::op_query_parser::parse_op_query;
    use crate::mongo::utils::{parse_bson_document, parse_cstring, parse_u32};

    fn get_bufer() -> &'static [u8] {
        let buffer: &[u8] = &[
            0x0d,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xd4,0x07,0x00,0x00,
            0x00,0x00,0x00,0x00,0x61,0x64,0x6d,0x69,0x6e,0x2e,0x24,0x63,0x6d,0x64,0x00,0x00,
            0x00,0x00,0x00,0x01,0x00,0x00,0x00,0xe6,0x00,0x00,0x00,0x10,0x69,0x73,0x4d,0x61,
            0x73,0x74,0x65,0x72,0x00,0x01,0x00,0x00,0x00,0x03,0x63,0x6c,0x69,0x65,0x6e,0x74,
            0x00,0xcb,0x00,0x00,0x00,0x03,0x61,0x70,0x70,0x6c,0x69,0x63,0x61,0x74,0x69,0x6f,
            0x6e,0x00,0x1d,0x00,0x00,0x00,0x02,0x6e,0x61,0x6d,0x65,0x00,0x0e,0x00,0x00,0x00,
            0x4d,0x6f,0x6e,0x67,0x6f,0x44,0x42,0x20,0x53,0x68,0x65,0x6c,0x6c,0x00,0x00,0x03,
            0x64,0x72,0x69,0x76,0x65,0x72,0x00,0x3a,0x00,0x00,0x00,0x02,0x6e,0x61,0x6d,0x65,
            0x00,0x18,0x00,0x00,0x00,0x4d,0x6f,0x6e,0x67,0x6f,0x44,0x42,0x20,0x49,0x6e,0x74,
            0x65,0x72,0x6e,0x61,0x6c,0x20,0x43,0x6c,0x69,0x65,0x6e,0x74,0x00,0x02,0x76,0x65,
            0x72,0x73,0x69,0x6f,0x6e,0x00,0x06,0x00,0x00,0x00,0x34,0x2e,0x30,0x2e,0x31,0x00,
            0x00,0x03,0x6f,0x73,0x00,0x56,0x00,0x00,0x00,0x02,0x74,0x79,0x70,0x65,0x00,0x07,
            0x00,0x00,0x00,0x44,0x61,0x72,0x77,0x69,0x6e,0x00,0x02,0x6e,0x61,0x6d,0x65,0x00,
            0x09,0x00,0x00,0x00,0x4d,0x61,0x63,0x20,0x4f,0x53,0x20,0x58,0x00,0x02,0x61,0x72,
            0x63,0x68,0x69,0x74,0x65,0x63,0x74,0x75,0x72,0x65,0x00,0x07,0x00,0x00,0x00,0x78,
            0x38,0x36,0x5f,0x36,0x34,0x00,0x02,0x76,0x65,0x72,0x73,0x69,0x6f,0x6e,0x00,0x07,
            0x00,0x00,0x00,0x31,0x38,0x2e,0x32,0x2e,0x30,0x00,0x00,0x00,0x00
        ];
        buffer
    }

    #[test]
    fn test_parse_u32() {
        let res = parse_u32(&[0x0d,0x01,0x00,0x00]);
        let (num, next_buffer) = res.unwrap();
        assert_eq!(269, num);
        assert_eq!(next_buffer.len(), 0);
    }

    #[test]
    fn test_parse_u32_error() {
        match parse_u32(&[0x0d]) {
            Ok(_) => {
                assert!(false, "buffer size less then 4 should return an error");
            }
            Err(_) => {
                assert!(true);
            }
        }
    }

    #[test]
    fn test_parse_msg_header() {
        let buffer = get_bufer();
        let (message_header, _) = parse_msg_header(buffer).unwrap();
        assert_eq!(message_header.message_length, 269);
        assert_eq!(message_header.request_id, 0);
        assert_eq!(message_header.response_to, 0);
        assert_eq!(message_header.op_code, 2004);
    }

    #[test]
    fn test_parse_cstring() {
        let buffer = get_bufer();
        let (_, next_buffer) = parse_msg_header(buffer).unwrap();
        let (_, next_buffer) = parse_u32(next_buffer).unwrap();
        let (res, _) = parse_cstring(next_buffer).unwrap();
        assert_eq!(res.to_str().unwrap(), "admin.$cmd");
    }

    #[test]
    fn test_parse_cstring_error() {
        let buffer = [0x70,0x70,0x6c,0x69,];
        match parse_cstring(&buffer) {
            Ok((val, _)) => {
                assert!(false, "buffer is not a legal format for cstring");
            },
            Err(_) => {
                assert!(true);
            }
        }
    }

    #[test]
    fn test_parse_bson_document() {
        let buffer = get_bufer();
        let (_, next_buffer) = parse_msg_header(buffer).unwrap();
        let (_, next_buffer) = parse_u32(next_buffer).unwrap();
        let (_, next_buffer) = parse_cstring(next_buffer).unwrap();
        let (_, next_buffer) = parse_u32(next_buffer).unwrap();
        let (_, next_buffer) = parse_u32(next_buffer).unwrap();
        let (doc, next_buffer) = parse_bson_document(next_buffer).unwrap();
        assert_eq!(doc.contains_key("isMaster"), true);
        assert_eq!(doc.contains_key("client"), true);
    }

    #[test]
    fn test_parse_op_query() {
        let buffer = get_bufer();
        let (header, next_buffer) = parse_msg_header(buffer).unwrap();
        let op_query = parse_op_query(header, next_buffer).unwrap();
        assert_eq!(op_query.flags, 0);
        assert_eq!(op_query.number_to_skip, 0);
        assert_eq!(op_query.number_to_return, 1);
        assert_eq!(op_query.return_fields_selector, None);
    }
}

use bson::Document;

use crate::cortices::mongo::error::{MongoParserError, MongoSerializeError};
use crate::cortices::mongo::ops::msg_header::{serialize_msg_header, MsgHeader};
use crate::cortices::mongo::utils::{parse_bson_document, parse_u32, parse_u64};
use crate::declarations::errors::{UnumError, UnumResult};
use crate::utils::{u32_to_u8_array, u64_to_u8_array};

/// @see https://docs.mongodb.com/manual/reference/mongodb-wire-protocol/#op-reply
#[derive(Debug)]
pub struct OpReply {
    // standard message header
    pub message_header: MsgHeader,

    // bit vector
    pub response_flags: u32,

    // cursor id if client needs to do get more's
    pub cursor_id: u64,

    // where in the cursor this reply is starting
    pub starting_from: u32,

    // number of documents in the reply
    pub number_returned: u32,

    // documents
    pub documents: Vec<Document>,
}

pub fn parse_op_reply(message_header: MsgHeader, buffer: &[u8]) -> UnumResult<OpReply> {
    let (response_flags, next_buffer) = parse_u32(buffer)?;
    let (cursor_id, next_buffer) = parse_u64(next_buffer)?;
    let (starting_from, next_buffer) = parse_u32(next_buffer)?;
    let (number_returned, mut next_buffer) = parse_u32(next_buffer)?;
    let mut documents = vec![];
    // TODO(#32)
    for _ in 0..number_returned {
        let (document, rest_buffer) = parse_bson_document(next_buffer)?;
        next_buffer = rest_buffer;
        documents.push(document);
    }
    if next_buffer.len() != 0 {
        return Err(UnumError::MongoParser(MongoParserError::InputBufferError));
    }
    Ok(OpReply {
        message_header,
        response_flags,
        cursor_id,
        starting_from,
        number_returned,
        documents,
    })
}

pub fn serialize_op_reply(op_reply: &OpReply) -> UnumResult<Vec<u8>> {
    if (op_reply.number_returned as usize) != op_reply.documents.len() {
        return Err(UnumError::MongoSerializer(
            MongoSerializeError::InputObjectError,
        ));
    }
    let mut res_buffer = serialize_msg_header(&op_reply.message_header);
    res_buffer.append(&mut u32_to_u8_array(op_reply.response_flags).to_vec());
    res_buffer.append(&mut u64_to_u8_array(op_reply.cursor_id).to_vec());
    res_buffer.append(&mut u32_to_u8_array(op_reply.starting_from).to_vec());
    res_buffer.append(&mut u32_to_u8_array(op_reply.number_returned).to_vec());
    for document in &op_reply.documents {
        match bson::encode_document(&mut res_buffer, document) {
            Ok(_) => {}
            Err(error) => {
                return Err(UnumError::MongoSerializer(
                    MongoSerializeError::SerializeBsonError(error),
                ));
            }
        }
    }
    Ok(res_buffer)
}

#[cfg(test)]
mod op_reply_tests {

    use crate::cortices::mongo::ops::msg_header::parse_msg_header;
    use crate::cortices::mongo::ops::op_reply::{parse_op_reply, serialize_op_reply};

    static OP_REPLY_FIXTURE: [u8; 442] = [
        0xaa, 0x01, 0x00, 0x00, 0x91, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00,
        0x00, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0xcb, 0x00, 0x00, 0x00, 0x08, 0x69, 0x73, 0x6d, 0x61,
        0x73, 0x74, 0x65, 0x72, 0x00, 0x01, 0x10, 0x6d, 0x61, 0x78, 0x42, 0x73, 0x6f, 0x6e, 0x4f,
        0x62, 0x6a, 0x65, 0x63, 0x74, 0x53, 0x69, 0x7a, 0x65, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10,
        0x6d, 0x61, 0x78, 0x4d, 0x65, 0x73, 0x73, 0x61, 0x67, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x42,
        0x79, 0x74, 0x65, 0x73, 0x00, 0x00, 0x6c, 0xdc, 0x02, 0x10, 0x6d, 0x61, 0x78, 0x57, 0x72,
        0x69, 0x74, 0x65, 0x42, 0x61, 0x74, 0x63, 0x68, 0x53, 0x69, 0x7a, 0x65, 0x00, 0xa0, 0x86,
        0x01, 0x00, 0x09, 0x6c, 0x6f, 0x63, 0x61, 0x6c, 0x54, 0x69, 0x6d, 0x65, 0x00, 0x9e, 0xd1,
        0xfe, 0xbc, 0x69, 0x01, 0x00, 0x00, 0x10, 0x6c, 0x6f, 0x67, 0x69, 0x63, 0x61, 0x6c, 0x53,
        0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x54, 0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x4d, 0x69,
        0x6e, 0x75, 0x74, 0x65, 0x73, 0x00, 0x1e, 0x00, 0x00, 0x00, 0x10, 0x6d, 0x69, 0x6e, 0x57,
        0x69, 0x72, 0x65, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x10, 0x6d, 0x61, 0x78, 0x57, 0x69, 0x72, 0x65, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e,
        0x00, 0x07, 0x00, 0x00, 0x00, 0x08, 0x72, 0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0x00,
        0x00, 0x01, 0x6f, 0x6b, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f, 0x00, 0xcb,
        0x00, 0x00, 0x00, 0x08, 0x69, 0x73, 0x6d, 0x61, 0x73, 0x74, 0x65, 0x72, 0x00, 0x01, 0x10,
        0x6d, 0x61, 0x78, 0x42, 0x73, 0x6f, 0x6e, 0x4f, 0x62, 0x6a, 0x65, 0x63, 0x74, 0x53, 0x69,
        0x7a, 0x65, 0x00, 0x00, 0x00, 0x00, 0x01, 0x10, 0x6d, 0x61, 0x78, 0x4d, 0x65, 0x73, 0x73,
        0x61, 0x67, 0x65, 0x53, 0x69, 0x7a, 0x65, 0x42, 0x79, 0x74, 0x65, 0x73, 0x00, 0x00, 0x6c,
        0xdc, 0x02, 0x10, 0x6d, 0x61, 0x78, 0x57, 0x72, 0x69, 0x74, 0x65, 0x42, 0x61, 0x74, 0x63,
        0x68, 0x53, 0x69, 0x7a, 0x65, 0x00, 0xa0, 0x86, 0x01, 0x00, 0x09, 0x6c, 0x6f, 0x63, 0x61,
        0x6c, 0x54, 0x69, 0x6d, 0x65, 0x00, 0x9e, 0xd1, 0xfe, 0xbc, 0x69, 0x01, 0x00, 0x00, 0x10,
        0x6c, 0x6f, 0x67, 0x69, 0x63, 0x61, 0x6c, 0x53, 0x65, 0x73, 0x73, 0x69, 0x6f, 0x6e, 0x54,
        0x69, 0x6d, 0x65, 0x6f, 0x75, 0x74, 0x4d, 0x69, 0x6e, 0x75, 0x74, 0x65, 0x73, 0x00, 0x1e,
        0x00, 0x00, 0x00, 0x10, 0x6d, 0x69, 0x6e, 0x57, 0x69, 0x72, 0x65, 0x56, 0x65, 0x72, 0x73,
        0x69, 0x6f, 0x6e, 0x00, 0x00, 0x00, 0x00, 0x00, 0x10, 0x6d, 0x61, 0x78, 0x57, 0x69, 0x72,
        0x65, 0x56, 0x65, 0x72, 0x73, 0x69, 0x6f, 0x6e, 0x00, 0x07, 0x00, 0x00, 0x00, 0x08, 0x72,
        0x65, 0x61, 0x64, 0x4f, 0x6e, 0x6c, 0x79, 0x00, 0x00, 0x01, 0x6f, 0x6b, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0xf0, 0x3f, 0x00,
    ];

    #[test]
    fn test_parse_op_reply() {
        let buffer = OP_REPLY_FIXTURE;
        let (header, next_buffer) = parse_msg_header(&buffer).unwrap();
        let op_query = parse_op_reply(header, next_buffer).unwrap();
        assert_eq!(op_query.response_flags, 8);
        assert_eq!(op_query.cursor_id, 0);
        assert_eq!(op_query.starting_from, 0);
        assert_eq!(op_query.number_returned, 2);
        assert_eq!(op_query.documents[0].contains_key("ismaster"), true);
        assert_eq!(
            op_query.documents[0].contains_key("maxBsonObjectSize"),
            true
        );
        assert_eq!(
            op_query.documents[0].contains_key("maxMessageSizeBytes"),
            true
        );
        assert_eq!(
            op_query.documents[0].contains_key("maxWriteBatchSize"),
            true
        );
        assert_eq!(op_query.documents[0].contains_key("localTime"), true);
        assert_eq!(
            op_query.documents[0].contains_key("logicalSessionTimeoutMinutes"),
            true
        );
        assert_eq!(op_query.documents[0].contains_key("minWireVersion"), true);
        assert_eq!(op_query.documents[0].contains_key("maxWireVersion"), true);
        assert_eq!(op_query.documents[0].contains_key("readOnly"), true);
        assert_eq!(op_query.documents[0].contains_key("ok"), true);
        assert_eq!(op_query.documents[0].get_f64("ok").unwrap(), 1.0);
        assert_eq!(op_query.documents[0].get_bool("readOnly").unwrap(), false);
    }

    #[test]
    fn test_serialize_op_reply() {
        let buffer = OP_REPLY_FIXTURE;
        let (header, next_buffer) = parse_msg_header(&buffer).unwrap();
        let op_query = parse_op_reply(header, next_buffer).unwrap();
        let op_reply_buffer = serialize_op_reply(&op_query).unwrap();
        assert_eq!(op_reply_buffer, buffer.to_vec());
    }
}
